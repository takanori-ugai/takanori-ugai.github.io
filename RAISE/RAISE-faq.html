<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="format-detection" content="telephone=no">
    <title>RAISE FREQUENTLY ASKED QUESTIONS</title>
    <meta name="description" content="RAISE FREQUENTLY ASKED QUESTIONS">
    <meta property="og:type" content="website">
    <meta property="og:title" content="RAISE FREQUENTLY ASKED QUESTIONS">
    <meta property="og:description" content="RAISE FREQUENTLY ASKED QUESTIONS">
</HEAD>
<BODY>
<h2>RAISE FREQUENTLY ASKED QUESTIONS</h2>

このファイルは定期的に z-forum メーリングリストと Usenet の
comp.specification, comp.specification.z, comp.answers,
comp.software-eng のグループにポストされます.
ここには形式手法 RAISE に関して一般的にされる質問に対する
答えを集めたものです.

<p>
    Version: 1.16, Date and time: 95/02/15 08:47:56<BR>
    Maintained by: tcszyh@aie.lreg.co.uk<BR>
    Translated by: ugai@fujitsu.com<BR>
</p>

<H3>目次</H3>
<OL>
    <LI><A HREF="#No1">RAISE って何?</A></LI>
    <LI><A HREF="#No2">RAISE 手法って何?</A></LI>
    <LI><A HREF="#No3">RSL って何?</A></LI>
    <LI><A HREF="#No4">RSL を使ってどんなシステムが記述できるの?</A></LI>
    <LI><A HREF="#No5">RSL ではどんなシステムは記述できないの?</A></LI>
    <LI><A HREF="#No6">どんな支援ツールがあるの?</A></LI>
    <LI><A HREF="#No7">RSL はどんな記述スタイルを支援してくれるの?</A></LI>
    <LI><A HREF="#No8">RSL はどんなモジュラリティを持っているの?</A></LI>
    <LI><A HREF="#No9">RSL のクラス拡張というのはあるの?</A></LI>
    <LI><A HREF="#No10">RSL はオブジェクト指向はサポートしているの?</A></LI>
    <LI><A HREF="#No11">RAISE は並列も扱うことができるの?</A></LI>
    <LI><A HREF="#No12">RSL は実行可能なの?</A></LI>
    <LI><A HREF="#No13">RSL はどんな意味論を持っているの?</A></LI>
    <LI><A HREF="#No14">RAISE の実装って何?</A></LI>
    <LI><A HREF="#No15">theory extension て何?</A></LI>
    <LI><A HREF="#No16">なにが証明できるの?</A></LI>
    <LI><A HREF="#No17">RAISE を使うとテストにどんな影響があるの?</A></LI>
    <LI><A HREF="#No18">RSL は Z と比較するとどうなの?</A></LI>
    <LI><A HREF="#No19">RSL は VDM と比較するとどうなの?</A></LI>
    <LI><A HREF="#No20">RAISE とリファインメント計算との関係はどうなっているの?</A></LI>
    <LI><A HREF="#No21">だれが RAISE と RSL を使っているの?</A></LI>
    <LI><A HREF="#No22">ほかには RAISE を使っている人はどこかにいるの?</A></LI>
    <LI><A HREF="#No23">RAISE に関する文書はあるの?</A></LI>
    <LI><A HREF="#No24">RAISE を勉強するにはなにからはじめればいいの?</A></LI>
    <LI><A HREF="#No25">RAISE についてもっと知りたい時はどうすればいいの?</A></LI>
    <LI><A HREF="#No26">Contact information</A></LI>
    <LI><A HREF="#No27">この FAQ に足りないものがあったら誰にいえばいいの?</A></LI>
    <LI><A HREF="#No28">参考文献</A></LI>
</OL>
<H3>
    <A NAME="No1">
        RAISE って何?
    </A>
</H3>
RAISE は形式手法のひとつです. RAISE は "Rigorous Approach to
Industrial Software Engineering" の略です. RAISE では, ソフトウェアシ
ステムの開発に形式手法を工業的に使うための機能が提供されています.
RAISE の目的には, つぎのようなものを可能にする事があります.

<UL>
    <LI>より信頼性の高いソフトウェア</LI>
    <LI> よりエラーの少ないソフトウェア</LI>
    <LI> よく文書の整備されたソフトウェア</LI>
    <LI> より容易に保守が可能なソフトウェア</LI>
</UL>

RAISE はつぎの 2 つから構成されます.

<UL>
    <LI> 強力な仕様記述と設計のための言語である RAISE Specification Language (RSL)</LI>
    <LI> 統合的な開発方法</LI>
</UL>

仕様, 理論, 証明を作るための多くのツールによる支援があり,
その支援は, ツールによる支援に対する疑問のもとに考慮されたものです.

<p>
    RAISE 言語とツールはソフトウェア開発過程における仕様記述, 設計, 実装
    の各場面を支援することに焦点を合わせています.
</P>

<p>
    RAISE の目的は工業的なやりかたで計画され実行される規則を支援することに
    よってソフトウェア開発プロセスをより良くすることです. とくに RAISE は
    最終的にコンパイル可能なコードを作るまでずっと開発を支援します. RAISE
    を使うと仕様から実装までのすべての開発において形式的に記録が残され, こ
    のことが最適な保守作業の前提条件になっているのです.
</P>

<p>
    RAISE は `spepwise refinement' のパラダイム([Dij76],[Wir71],[Jon86])を
    使ったシステマティックなソフトウェア開発の20年の研究と経験の結果できた
    ものです. RAISE についてもっと明確に言うと, European Commission -
    RAISE (ESPRIT I 315, 1985 - 1990) と LACOS (ESPRIT II 5383, 1990 -
    1995, LArge scale COrrect Systems using formal methods) がスポンサーに
    なっている 2 つのプロジェクトがあり 200 人年以上の人がかかわっている.
</P>


<h3>
    <A NAME="No2">
        RAISE メソッドって何?
    </A>
</h3>
RAISE メソッドは, 要求獲得とプロジェクト管理と言うようにもっとも関連し
たソフトウェアとシステムの開発活動に関するガイドラインを持っています.
この方法論は stepwise refinement パラダイムに基づいたものです. このパ
ラダイムに関して, ソフトウェアは一連のステップを通じて作られます. それ
ぞれのステップでは, まえのステップで作られたものに対してリファインメン
トを行ないます. RAISE では, それぞれのステップでは `invent-and-verify'
という考え方で作られます. 仕様は `manually' (発見的側面) で設計が行な
われ, この 2 つの間の関係はあとで証明されます. (これはしばしば
posteriori verification と呼ばれます) RAISE は理論的な拡張として知られ
るある種のリファインメントを支援します. (これに関しては theory
extension の部分を見て下さい.)

<P>
    RAISE ではこの検証に関するツールによる支援があります. このような形式的
    検証が正しく行なわれることによって 得られる正しいソフトウェアに関する
    健全な基礎が得られることになります. しかしながら, 形式的証明はひとつ
    の可能性に過ぎないのです. 実際の工業的なアプリケーションに関しては,
    実際的な, あるいは経済的制約により検証はそれほど形式的には (それほど厳
    しくは) 行なわれません.
</P>

<P>
    RAISE メソッドは, 規定でもクッキングブックのようなものでもなくソフトウ
    ェア開発プロセスに関する枠組とガイドラインを与えるものです. このメソ
    ッドの柔軟さによってそれぞれのプロジェクトに実際的な問題を管理するため
    の厳しさのレベルを決めたり技術を選択したりすることができるのです.
    RAISE メソッドではユーザはそれぞれの環境やプロジェクトの標準などに応じ
    てどれ位形式的かというレベルを選択することができるのです.
</P>


<H3>
    <A NAME="No3">
        RSL って何?
    </A>
</H3>
RSL とは RAISE Specification Language のことです. これは領域の広い仕様
記述言語です. いくつかの仕様記述言語 (VDM, CSP & ACT-ONE) の機能を統合
したものです. RSL が `領域の広い' といっているのは抽象度の高い仕様を記
述することもでき, 同様に低レベルの設計も行なうことができるということで
す. (ループのような手続き的な記述をするためにも使えるということになり
ます) このようになっている利点のひとつは,ユーザは実装に使うプログラミ
ング言語以外にたったひとつの表記方法だけを知っていればいいということで
す. なぜなら開発全体が RSL を使って行なわれるからです. RSL の構成機能
は分解と再利用をサポートしています.

<P>
    RSL の仕様はソフトウェアシステムの数学的なモデルであると考えることがで
    きます. 開発の中で異なるレベルの仕様の違いは, 抽象度のレベルの違いとな
    ります.
</P>


<H3>
    <A NAME="No4">
        RSL を使ってどんなシステムが記述できるの?
    </A>
</H3>
RAISE から最も恩恵を受けることのできるソフトウェア開発プロジェクトの種
類というのは, データにせよ, アルゴリズムにせよ, 並列性にせよ,高信頼性
を必要とするにせよもともと非常に複雑なシステムの開発である. 典型的な
アプリケーションは, システムソフトウェア, 埋め込み型のソフトウェア,セ
イフティクリティカルなソフトウェアなどである.

<P>
    4 世代ツール (巨大なユーザインターフェイスの設計を含むようなある種の管
    理上のアプリケーション)によって簡単にできるようなソフトウェアの開発で
    はRAISE から同じように恩恵を受けることはできないでしょう.
</P>

RAISE はさまざまなところで利用され成功しています. 以下に列挙します.

<UL>
    <LI> ネットワーク設計ツールセット</LI>
    <LI> 無人運転列車の保護システム</LI>
    <LI> 船のエンジンのモニタリングシステム</LI>
    <LI> 画像処理</LI>
    <LI> 出荷管理</LI>
    <LI> 人工衛星による位置の確認システム</LI>
    <LI> 人工衛星のペイロード管理に関する器具管理ユニットを開発するための
        統合ツールセットの一部</LI>
    <LI> セキュリティアーキテクチャの記述 (Bell-La Padula & Bull's
        Sesame)</LI>
    <LI> 列車のモニタリングと再スケジューリングのためのシステム</LI>
</UL>

これらのプロジェクトのうちのいくつかについてはもっと詳しい情報を手に入
れることが可能です.

<H3>
    <A NAME="No5">
        RAISE ではどんなシステムは記述できないの?
    </A>
</H3>
RSL の仕様では時間や空間的制約のような機能ではない要求は,
直接扱うことはできません. RAISE ではそのかわりにそのような要求に対しては
どのように開発が実現されるかという時に考慮に入れます.
従っていろいろな開発工程でそのような要求が実現されます.

<P>
    しかしながら, RSL でモデル上の時間を扱うことは可能で, このような
    やりかたにしている理由は実時間性についてのみです.
</P>


<H3>
    <A NAME="No6">
        どんな支援ツールがあるの?
    </A>
</H3>
RAISE のツールは 1991 年の半ばから商業的に入手可能です.

<P>
    言語と方法論を支援する十分利用に耐えるツールのセットがあります. RAISE
    のツールは完全に形式的な仕事のやりかたを証明の追跡と validationなどを
    使って支援し, もっと緩やかなやりかたと同じように仕事を行なうことができ
    ます.
</P>

<p>
    RAISE のツールは, 開発中のさまざまなもの (モジュール, モジュール間の関
    係,理論, 正当性, ヒント)のエディット, 操作をするためのツールの集まりに
    なっています. RAISE のツールで提供される環境はソフトウェアシステムの開
    発全体を追跡し, 文書化する機能を提供しています. この環境はそのソフト
    ウェアのライフタイムすべてに渡って保守, 発展を支援します. 現在この環境
    は Unix と X を用いて Sun ワークステーション上で動作します.
</p>

以下のようなツールがあります.

<UL>
    <LI> エディット</LI>
    <LI> 正当性の評価の実行</LI>
    <LI> 手続き型言語への変換</LI>
    <LI> 文書化の支援</LI>
</UL>

エディタは文法を管理するエディタで, ユーザは(マウスとキーを使って)文法
範疇を選んでリファインします. あるいは普通のテキストエディタのように使
います. その時には, カットアンドペーストのような通常のエディタの機能を
使ってタイプし, エディットすることができます. エディタは文法を守り,静
的条件 (型規則, 視界規則など)をチェックし, エラーの場所で関連したエラ
ーメッセージを表示します. 他の実体への参照は `contexts' を通して作ら
れます.

<p>
    正当性エディタは会話的に論理的正当性を開発するために使われ,後向き推論
    にも前向き推論に使われます. 正当性エディタは,重要な機能を持っています.
</P>

<UL>
    <LI> 簡素化機能. この機能は証明の規則を自動的に適用することによってより簡
        潔な条件に縮小するために使われます. (一番いいのは真にすること)</LI>

    <LI> 実装条件拡張機能. この機能は 2 つのモジュール間の実装の関係が成り立
        つ時に詳細な条件をつくり出す時に使われます.</LI>
</UL>

変換器は RSL で書かれた低レベルの仕様からコンパイル可能なプログラミン
グ言語のコードをつくり出すために使われます. C++ と Ada の変換器があり,
高性能に関する要求がある RSL モジュールに関しては, 手動での変換や, 変
換されたコードの改良が必要になります.

<P>
    文書整形器は, RAISE の実体を適当な形で抜き出し, 非形式的なテキストと
    RAISE の実体を含むような紙による文書をつくり出すために使われます現在
    LaTeX の整形システムのみがサポートされています. しかしながら, 正当性
    以外の実体は ASCII で手に入れることもでき,特殊文字は ASCII の列に変換
    されます.
</P>


<H3>
    <A NAME="No7">
        RSL はどんな記述スタイルを支援してくれるの?
    </A>
</H3>
RSL 次のようなスタイルを支援します.

<UL>
    <LI> Z や VDM で使われるようなモデル指向の仕様. このスタイルを使うと仕様
        の中で使われるデータは `モデル化' されたものになります. 例えばスタック
        は値の列としてモデル化されます. データに関する操作はデータのモデルにど
        のように働くかが記述されます. スタックの例では値をプッシュすることは列
        の最初に値を加えることで, ポップすることは列の最初の値を取り除くことと
        等価になります.</LI>

    <LI> Larch や OBJ で使われるような代数仕様. これはモデル指向よりももっと
        抽象度が高い. このスタイルではデータはデータについての性質を表す公理を
        用いて記述されます. スタックの例ではスタック s と要素 x に対して
        pop(sushi(x,s)) = s を定義します. このスタイルでは, 多くのモデルで公
        理を充足します. RAISE メソッドでは代数仕様は一般にもっと具体的なデータ
        構造が設計されるようにモデル指向で開発されます.</LI>

    <LI> Lisp, Miranda, Haskell のような applicative なプログラミング言語で用
        いられるスタイルのような applicative 仕様. 大域的実行履歴や状態のよう
        なものはなく, 変数もありません. パラメタに関数を適用した結果が関数に
        対するパラメタの機能なのです. 手続きのようなものもありません. したが
        って同じパラメタに対する関数を適用した結果は常に同じ結果になります.</LI>

    <LI> C, Modula-2, Pascal などの手続き型プログラミング言語で用いられるよう
        な手続き的仕様. このスタイルの顕著な特徴は, 実行履歴, 大域状態である.
        変数が定義でき, 変更できる. したがって手続きの適用の順番が結果に重要な
        影響をもたらす.</LI>

    <LI> CSP で使うような並行の仕様. 並行プロセスは同期チャンネルを通して互い
        に通信を行なうように定義されます.</LI>

    <LI> pre- post- 条件を用いたインプリシットな定義</LI>

    <LI> エクスプリシットな定義</LI>
</UL>


<H3>
    <A NAME="No8">
        RSL はどんなモジュラリティを持っているの?
    </A>
</H3>
RSL は構造のレベルにパラメタ化を用いたモジュラリティをサポートしていま
す.

<p>
    RSL のモジュールは, 基本的なブロックと抽象的なユニットで構成されてい
    て, RAISE による開発は, これらを組み上げていくことである. モジュール
    内部では RSL のエンティティすなわち, タイプ, 値, 変数, チャンネル,オブ
    ジェクトとほかのモジュールが定義される. RSL モジュールは プログラミン
    グ言語で言われる `モジュール', `パッケージ', `クラス' などに相当しま
    す. モジュールが自分のエンティティを定義している他のモジュールのエン
    ティティを参照できるので, RSL による仕様は, 階層的に構成されます. モ
    ジュールはパラメタ化され, generalised 仕様をサポートしています. これ
    は再利用可能なモジュールを作るために重要な機構です. モジュールは, そ
    のエンティティの名前を替えたり隠したりすることによって与えられた環境に
    適合させることができます.
</P>


<H3>
    <A NAME="No9">
        RSL のクラス拡張というのはあるの?
    </A>
</H3>
RSL では基本的なブロックを組み立てることがクラスの拡張であってしばし
ば, RSL モジュールとして参照されます. すべての宣言は, クラスの拡張で
行なわれます. ここには, タイプ, 定数, 関数, 変数, チャンネル,オブジェ
クトの定義が含まれています. スキーマは名前付きのクラスの拡張でクラスの
拡張のモデルを示しています. それぞれのスキーマやクラスの拡張はあるスキ
ーマやクラスの拡張の一つのインタンスを示していて名前付きのオブジェクト
としてインスタンス化され, すくなくとももとのスキーマやクラスの拡張で定
義されたすべての性質は持っています.

<p>
    クラスの拡張は他のクラスの拡張によってパラメタ化されることがあります.
    そのようにして作られた仮引数は, 実引数から必要な性質を定義します. こ
    れらの性質は, パラメタ化されたクラスの拡張で利用可能となるものです.
</p>


<h3>
    <A NAME="No10">
        RSL はオブジェクト指向はサポートしているの?
    </A>
</h3>
RAISE はオブジェクト指向に必要な(サブタイプ) 多相, 継承, 隠蔽などをサ
ポートしています. 一般的に言って RAISE はすべてのオブジェクト指向言語の
機能を合わせたもの以上のオブジェクト指向手法をサポートしています.

<dl>
    <dt>多相
    <dd> RSL はサブタイプ多相 (あるタイプのサブタイプにある値の型を定義して関
        数を適用できるようにすること)をサポートしていますが, 動的バインディン
        グはサポートしていません.

        <p>
            RSL は (例えば ML にあるような) パラメータの多相はサポートしていませ
            ん. しかしながら, 関数 `テンプレート' はあるタイプで実体化されるよう
            に定義することができます. 例えば, タイプ ELEM 上にいくつかの関数を定義
            したモジュールは, タイプ ELEM を定義しているモジュールをパラメータとし
            て持つことができます.
        </p>

        <code><pre>
   scheme LIST_FUNS(E : class type Elem end) =
     class
       value 
         reverse : E.Elem-list - &gt; E.Elem-list
         reverse(seq) is ...
         ...
     end
</pre>
        </code>

        いまこの関数は任意の型で定義されていて ELEM で実体化して使われます.
        パラメタ化の機能を使うと, パラメタの多相よりもより一般的なことができま
        す. 例えば, パラメタは公理による仕様を含むことができるので, Elem が全
        順序の形になることができます.

        <p>
            RSL では関数の上書きをすることができるので, どの関数も上書きが静的に解
            決できるのであれば何回でも宣言することができます. すなわち異なる関数の
            定義は, それぞれのタイプ と/または 数のパラメタに対して適用しなければ
            なりません.
        </p>

    <dt> 継承

    <dd>
        継承は RSL の `拡張' 機能を使って行ないます. 他を拡張したモジュールは
        その定義と状態を継承します. しかしながら, 複数からの継承を行なった時に
        継 承の不一致が起こった時の解決をする方法はありません. その不一致は静的
        なチェックを行なっている時にエラーとして報告されます. 複数からの継承
        は, 共有されるものを明示的なやりかた(パラメタ化によって)で仕様化されな
        ければなりません.

    <dt> 隠蔽

    <dd> 隠蔽は RSL の `hide' 機能を使って行ないます. この機能によってモジュー
        ルの中で定義されるエンティティが隠され, モジュールの外から参照できなく
        なります

</dl>
RSL は直接的には, オブジェクトの動的実体化をサポートしていません. そ
れはこの機能があると非常に難しい証明システムを作らなければならなくなる
からです. 動的オブジェクトはオブジェクトの配列を使ってモデル化されま
す.


<h3>
    <A NAME="No11">
        RAISE は並行も扱うことができるの?
    </A>
</H3>
はい: RSL の主要な設計意図は, 一つの仕様記述言語で並行と, 逐次を統合す
ることでした. 並列に動作するものは RSL のプロセスの概念で仕様化されま
す. プロセスは (i) チャンネルを通して他のプロセスと通信を行ない, (ii)
状態へのアクセスが可能なものであると考えられます. 通信は同期して行な
われます. RSL のプロセスの概念はCSP ([Hoa85]) に見られるプロセス代数の
概念をもとにしたものです.

<p>
    RSL のプロセスは, 入力, 出力, 選択, 並列合成を含む式を使って明示的に
    仕様化され, 公理的な仕様が作られます.
    並行動作を公理的に仕様化するために, RSL は特殊な `interlock'
    演算を持っています.
</p>


<h3>
    <A NAME="No12">
        RSL は実行可能なの?
    </A>
</h3>
いいえ: 現在 RSL のコンパイラもインタプリタもありません. しかしなが
ら, 手続き型のコードに非常に近い RSL による仕様は書くことができます.
選択した言語に依存したコードにそれを変換することは比較的簡単です. C++
や Ada への変換器を使って自動的に, あるいは手動で可能です. このように
して生成されたコードはコンパイルすることもできるし, インタープリタで動
かすこともできます.


<h3>
    <A NAME="No13">
        RSL はどんな意味論を持っているの?
    </A>
</h3>
RSL の形式的, 数学的記述は"Semantic Foundations of RSL" [Mil90a] に書
かれています. ここでは,宣言的意味論が与えられています. "The Proof
Theory for the RAISE Specification Language" [Mil90b]には公理的意味論
が与えられています. 宣言的モデルの構築とその存在証明は, [BD92a] と
[BD92b] でなされています.


<h3>
    <A NAME="No14">
        RAISE の実装ってなに?
    </A>
</h3>
仕様の意味と同様に開発の意味を提供するための形式的システムと言うのは,
実装の記述までを提供しなければならないものです. もし, モジュール A0
が, モジュール A1 へと開発が進んだならば, A1 が `正しく' 開発されたこ
とを知る必要があります. それが A0 を実装したものであるならば A1 は正
しいといいます. すなわち, A0 と A1 が実装関係にあると言います. 実際
には実装の記述はいくつかバリエーションが考えられます. (これをリファイ
ンメントとかレイフィケーションと言います) RAISE では theory extension
であり 2 つの要求を合わせて選択されるのです. もし A1 が A0 の実装であ
るならば次のことが言えて欲しいのです.

<UL>
    <LI> Property Preservation: A0 について証明されるすべての性質が
        A0 に関しても証明される. (一般的には,なりたたない)

    <LI> Substitutivity: 仕様の中で A0 のインスタンスが A1 のインスタンスで
        置き換え可能であり, 新しくできた仕様がまえの仕様の実装になっている.
</UL>


<h3>
    <A NAME="No15">
        theory extension て何?
    </A>
</h3>
[RMG95] からの定義を挙げておきます.

<UL>
    <LI> 理論 T2 が 理論 T1 よりより多くの実体 と/または 性質を持つ時に
        T2 は T1 を拡張する.
    <LI> 理論 T1 で定義される実体を使って表現される理論 T2 のすべての性質が
        T1 の性質であるとき T2 は T1 を保守的に拡張する. 言い替えれば,
        T2 は T1 からの実体に対して何も新しい性質を加えない. 保守的でない拡張は
        `非保守的' と言う.
</UL>


<h3>
    <A NAME="No16">
        なにが証明できるの?
    </A>
</h3>
RAISE は証明というよりも `正当性' という言葉を使います. これはある条
件の真偽を示すものです. そのような論証は全体として形式的なものになりま
す. すなわち, RSL の証明規則を適用することに基づいた数学的な証明となり
ます. しかしながら, ある産業的なアプリケーションに関して, 実際的, 経
済的制限を満たす場合には正当性というのはもっと非形式的でも良いもので
す. 非形式的な論証を利用するという考え方は, 形式的証明がどのように作
られるかということを示すことです. 言い替えれば, 非形式的な論証が使われ
る時は,形式的な証明で置き換えられると言うことを確信していなければなり
ません. 形式的な基礎にもとづいているが, 非形式的なものを許すそのよう
な論証は厳密だと言われます.

<p>
    RAISE を使って作成されて正当化される条件には次の 2 種類があります.
</p>

<UL>
    <LI> formal condition (RAISE の理論で明記される述語と開発関係). これらは
        手で作らなければならない.

    <LI> confidence confition (RSL の部品では最終的とはならなく,予想できない
        意味がある信頼性を増すための述語). これらは自動的に生成される.
</UL>


<h3>
    <A NAME="No17">
        RAISE を使うとテストにどんな影響があるの?
    </A>
</h3>
RAISE は潜在的には, ソフトウェアのテストを少なくすることができるはずで
す. なぜなら, プログラムはすでに再利用可能なように記述されていて,開発
プロセスの一部は RAISE の正当性ツールを使って形式的に正しいことが示さ
れているからです. このことはある意味でテストを少なくすることを意味して
いるわけではなく, コード野中にエラーが入り込まないようにしてテストに失
敗しないようにしてやり直しやテストのし直しを減らすということを意味して
いるのです. 形式仕様の成果物は, テストケースの生成の助けにもなるでしょ
う.


<h3>
    <A NAME="No18">
        RSL は Z と比較するとどうなの?
    </A>
</h3>
Z は基本的に仕様記述言語です. 一般的に仕様を作るためには適していますが
開発に関する他の記述に使うためにはやや適していません. 一方 RSL は仕様
記述にも開発にも利用することができます.

<p>
    RSL は 低レベルの仕様や並列性の機能に関して Z よりも優れています. し
    たがって, Z の仕様を RSL の仕様に変換することは, その逆よりは容易です.
</p>

<p>
    Z と RSL の仕様記述のスタイルはしばしば全く異なるものになります. Z の
    仕様は モデルベース, 主として applicative のスタイルで書かれます. 一
    方 RSL は applicative と imperative のスタイルから一方を選択することが
    できます. あるいは代数仕様とモデルベース仕様から選択することができま
    す. 抽象レベルの違うものを仕様化することができるようになっていること
    によって, RSL はあるレベルから別のレベルへの開発を可能にしているので
    す.
</p>
<p>
    仕様の部品(Z ではスキーム, RSL ではモジュール) を組み合わせることは
    RSL よりも Z の方が容易です. (文法上のオーバヘッドが少ない) しかしなが
    らおそらく大きなソフトウェアに関しては再利用性は低いでしょう. RSL の構
    造化の仕組みはある種の ML の拡張のようなものです. 例えば, モジュール
    は他のモジュール上でパラメタ化することができ, RSL は パラメータとして
    提供されるモジュールからの識別子を使うことができます. ただし, パラメタ
    の名前でそれを前置しなければなりません.
</p>


<p>
    Z も RSL もある関数が適用された時に変更が無いような状態の細かな多くの
    無意味の述語を入れるよりもより小さな状態に分けることが良いとしていま
    す. Z は一般的にそれぞれの小さな状態 (しばしば, ある特定の状態にそれぞ
    れの関数が適用可能になるのですが)をそれぞれ別のスキーマで扱います. 一
    方 RSL は小さな状態を一つ以上のモジュールで関数を組み合わせます. これ
    は一般的に Z の仕様には多くの小さなスキーマが出現し, それとは対照的に,
    RSL の仕様ではより少ない大きなモジュールで構成されることになります.
</p>

<H3>
    <A NAME="No19">
        RSL は VDM と比較するとどうなの?
    </A>
</H3>
RSL は VDM に並列, 公理, 手続きの各スタイルのような機能を加えて作られ
たものです. モジュラリティは, RSL の機能として導入されたもので, RAISE
メソッドは VDM の一部としてサポートされるのではない. いくつかのものが
VDM にモジュラリティを加えて作られたが,まだ広く受け入れられたものはな
い. VDM のコミュニティで広く受け入れられている記述のいくつかはRSL にも
含まれている. 例えば, 型構成子, マップ, 集合, リスト, 直積などはその
式や関数定義の書き方とともに利用されている. (pre-/post- のスタイルも).

<p>
    VDM を使った相当数のケーススタディが発表されている. VDM を使った時の
    形式的な側面のシステマティックな重要性とともにソフトウェアのモデリン
    グ, 仕様化, 開発のための相当量の技術や戦略が発表されていて,それらは
    RSL でも容易に利用することができる.
</p>

<h3>
    <A NAME="No20">
        RAISE とリファインメント計算との関係はどうなっているの?
    </A>
</h3>
リファインメント計算は, リファインメントの計算的 (あるいは
変換的) やりかたを取っていますが RAISE は invent-and-verify 法を
取っています. この 2 つの形式的手法は本質的に異なる目的を持っています.
RAISE は大きなソフトウェア開発を目指していますが, リファインメント計算は
主にプログラムを数学的に導き出すために使われています.

<h3>
    <A NAME="No21">
        だれが RAISE と RSL を使っているの?
    </A>
</h3>

RAISE ユーザとして登録されているのはつぎのところです.<BR>
CRI A/S (Denmark) - tool suppliers, <BR>
BNR Europe Ltd (UK), <BR>
Bull SA (France), <BR>
Inisel Espacio SA (Spain), <BR>
Lloyd's Register (UK), <BR>
MATRA Transport SA (France), <BR>
Space Software Italia SA (Italy), <BR>
Technisystems Ltd (Greece), <BR>
CAP Programator (Denmark).<BR>


<H3>
    <A NAME="No22">
        ほかには RAISE を使っている人はどこかにいるの?
    </A>
</H3>
何人かの人は comp.specification のニュースグループにいます. 興味があ
るならば,メーリングリストも解説されるでしょう. さらに詳細については,
"" と連絡を取ってみて下さい.

<p>
    ツールと一般的な情報に関しては Jan Storbank Pedersen &lt;jsp@csd.cri.dk&gt;
    コースと一般的な情報に関しては Maurice Naftalin &lt;tcsmpn@aie.lreg.co.uk&gt;
    と連絡を取ってみて下さい
</p>

WWW page:
<A HREF="http://dream.dai.ed.ac.uk/raise/">
    http://dream.dai.ed.ac.uk/raise/</A>


<H3>
    <A NAME="No23">
        RAISE に関する文書はあるの?
    </A>
</H3>
RAISE に関する文書にはつぎのようなものがあります.
<DL>
    <DT> RAISE Overview
    <DD> この文書には RAISE の考え方とその成立ちが書いてあり, 導入的な
        レベルで典型的な小さな例題を使って説明がされています.
        CRI から入手可能です. (つぎの章を見て下さい)

    <DT> The RAISE Specification Language
    <DD> この本は RSL のチュートリアルと RSL のリファレンスから構成されています.
        チュートリアルには RAISE Specification Language (RSL) の詳細な
        導入が含まれています. トレーニングコースの基礎と同じようなことを
        自分で勉強することを考えています. リファレンスの部分では,
        RAISE Specification Language (RSL) が詳細に定義されています.
        <P>
            この本は入手可能です.<BR>
            The RAISE Specification Language<BR>
            The RAISE Language Group<BR>
            Prentice Hall<BR>
            ISBN: 0-13-752833-7<BR>
        </P>

    <DT> The RAISE Development Method
    <DD> この本は RAISE を使って 仕様化, 開発, verification, validation,
        変換をどのように行なうかを, 勉強, トレーニング, 参考に利用されることを
        考えています.

        <P>
            これはまた RSL の仕様の性質を正当化したいと思っている人のための
            ハンドブックにもなると考えています. この本には RAISE の正当性に関する
            文法が記述されていて, 正当性の証明で利用される形式的証明規則が
            載っています.
        </P>

        <P>
            この本は 1995 年の春に出版される予定です.<BR>
            The RAISE Development Method<BR>
            The RAISE Method Group<BR>
            Prentice Hall<BR>
            ISBN: 0-13-752700-4<BR>
        </P>
</DL>


<H3>
    <A NAME="No24">
        RAISE を勉強するには, なにからはじめればいいの?
    </A>
</H3>
Lloyd's Register (UK) に調整可能なコースが 2 つあります.
Maurice Naftalin +44 81 681 4040 &lt;tcsmpn@aie.lreg.co.uk&gt; と
連絡を取ってみて下さい.

<UL>
    <LI> Introduction to RAISE
    <LI> Software Development using RAISE
</UL>

CRI (Denmark) には RSL と RAISE を用いた 1 日から 5 日間のコースがあります.
Jan Storbank Pedersen +45 45 82 21 00 &lt;jsp@csd.cri.dk&gt; と連絡を
取ってみて下さい

<UL>
    <LI> RAISE Tutorial (1 day)
    <LI> RSL and Method Course (3 days)
    <LI> RSL Course (5 days)
    <LI> RAISE Method Course (5 days)
    <LI> RAISE Justification Course (4 days)
</UL>

CRI からはビデオによるトレーニングコースもあります.
これは 10 本のテープで構成され, それぞれおよそ 50 分間です.

<P>
    CRI, CAP Programator と Lloyd's Register は顧問の仕事も行なっています.
</P>


<H3>
    <A NAME="No25">
        RAISE についてもっと知りたい時はどうすればいいの?
    </A>
</H3>
<A HREF="http://dream.dai.ed.ac.uk/raise/"> RAISE WWW page</A>
を見て下さい.

<p>
    RAISE を良く使っている人か,
</P>

<p>
    Maurice Naftalin at Lloyd's Register &lt;tcsmpn@aie.lreg.co.uk&gt;<BR>
    Jan Storbank Pedersen at CRI &lt;jsp@csd.cri.dk&gt;
</p>

に聞いて下さい.

<h3>
    <A NAME="No26">
        Contact information
    </A>
</H3>

<PRE>
Maurice Naftalin
Lloyd's Register
Lloyd's Register House
29, Wellesley Road,
Croydon CR0 2AJ	
UK

Tel: +44 81 681 4040
Fax: +44 81 681 4839
email: tcsmpn@aie.lreg.co.uk


Jan Storbank Pedersen
Computer Resources International A/S 
P.O.Box 173
Bregner{\o}dvej 144
DK-3460 Birker{\o}d
Denmark

Tel: +45 45 822100
Fax: +45 45 821711
email: jsp@csd.cri.dk

Eld Zierau
CAP Programator
Produktionsvej 2
2600 Glostrup
Denmark

Tel: +45 44 94 44 44
Fax: +45 44 94 62 42
email: ez@sypro.dk
</PRE>


<H3>
    <A NAME="No27">
        この FAQ に足りないものがあったら誰にいえばいいの?
    </A>
</H3>
この FAQ は LACOS プロジェクトのメンバーの知識や RSL 本[RLG92],
いくつかの CRI のリーフレット, RAISE Development Method [RMG94] などの
さまざまなレポートや文書から編集されたものです.

<p>
    この FAQ に関する示唆や訂正は,
    Zoe Hellinger at Lloyd's Register にして下さい.
</P>


<p>
    Zoe Hellinger, <BR>
    Lloyd's Register <BR>
    Lloyd's Register House, <BR>
    29, Wellesley Road,<BR>
    Croydon CR0 2AJ<BR>
    UK
</p>

email: tcszyh@aie.lreg.co.uk. <BR>

訳者注 : 日本語訳に関しては, 訳者まで.<BR>

<H3>
    <A NAME="No28">
        参考文献
    </A>
</H3>
<p>
    [BD92a] D. Bolignano and M. Debabi. On the Foundations of the RAISE
    Specification Language. LACOS Report Bull/DB/27, Bull Corporate
    Research Center, June 1992.
</p>

<p>
    [BD92b] D. Bolignano and M. Debabi. Higher Order Communicating
    Processes with Value-passing, Assignment and Return of Results. In
    Proceedings of the ISAAC'92 Conference. December 1992.
</p>

<p>
    [Dij76] E.W. Dijkstra. A Discipline of Programming. Prentice-Hall
    International, 1976
</p>

<p>
    [RLG92] The RAISE Language Group. THE RAISE Specification Language. The BCS
    Practioner Series. Prentice Hall, 1992 ISBN 0-13-752833-7
</p>

<p>
    [RMG95] The RAISE Method Group.. The RAISE Development Method. BCS
    Practitioner Series. Prentice Hall, 1995 ISBN 0-13-752700
    (To appear Spring 1995)
</p>


<p>
    [Hoa85] C.A.R. Hoare. Communicating Sequential Processes.
    Prentice-Hall series in Computer Science. Prentice-Hall International,
    1985
</p>

<p>
    [Jon86] C.B. Jones. Systematic Software Development using VDM.
    Prentice-Hall Series in Computer Science. Prentice-Hall International,
    1986
</p>

<p>
    [Mil90a] R. Milne. The proof theory for the RAISE specification
    language. RAISE Report REM/12, STC Technology Ltd, 1990.
</p>

<p>
    [Mil90b] R. Milne. The semantic foundations of the RAISE specification
    language. RAISE Report REM/11, STC Technology Ltd, 1990.
</p>

<p>
    [Wir71] N. Wirth. Program Development by Stepwise Refinement.
    Communications of the ACM, (14):221 - 227, 1971
</p>

<p>
    Simon Hughes<BR>
    Imperial College<BR>
    Email: sph@doc.ic.ac.uk<BR>
</p>
</BODY>
</HTML>
